<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>정보 은닉과 캡슐화 이해하기</title>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Prism.js for code highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    
    <!-- AOS for scroll animations -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.css">
    
    <!-- mermaid.js for diagrams -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js"></script>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="container header-content">
            <a href="#" class="logo">
                <i class="fas fa-code"></i>
                <span>CodeInsight</span>
            </a>
            <nav>
                <ul>
                    <li><a href="#">Home</a></li>
                    <li><a href="#">Articles</a></li>
                    <li><a href="#">Categories</a></li>
                    <li><a href="#">About</a></li>
                    <li><a href="#">Contact</a></li>
                </ul>
            </nav>
            <button class="mobile-menu-btn">
                <i class="fas fa-bars"></i>
            </button>
        </div>
    </header>

    <section class="hero">
        <div class="container hero-content">
            <h1>정보 은닉과 캡슐화 이해하기</h1>
            <div class="hero-meta">
                <div>
                    <i class="far fa-calendar"></i>
                    <span>May 18, 2025</span>
                </div>
                <div>
                    <i class="far fa-clock"></i>
                    <span>8 min read</span>
                </div>
                <div>
                    <i class="far fa-folder"></i>
                    <span>객체지향 프로그래밍</span>
                </div>
            </div>
            <p>객체지향 프로그래밍의 핵심 원칙인 정보 은닉과 캡슐화의 개념, 구현 방법 및 이점을 시각적 표현과 함께 알아봅니다.</p>
        </div>
    </section>

    <section class="content">
        <div class="container">
            <article class="article" data-aos="fade-up">
                <div class="article-content">
                    <div class="article-section">
                        <h2>정보 은닉과 캡슐화란?</h2>
                        <p>객체지향 프로그래밍(OOP)에서 <strong>정보 은닉(Information Hiding)</strong>과 <strong>캡슐화(Encapsulation)</strong>는 밀접하게 연관된 개념이지만 약간의 차이가 있습니다.</p>
                        
                        <div class="key-points">
                            <h4>핵심 개념</h4>
                            <ul>
                                <li><strong>정보 은닉:</strong> 객체의 내부 상태와 구현 세부사항을 외부로부터 숨기는 원칙</li>
                                <li><strong>캡슐화:</strong> 데이터(속성)와 해당 데이터를 조작하는 메서드(동작)를 하나의 단위로 묶는 메커니즘</li>
                            </ul>
                        </div>
                        
                        <p>정보 은닉이 "무엇을 숨길 것인가"에 대한 원칙이라면, 캡슐화는 "어떻게 숨길 것인가"에 대한 구현 방법입니다. 캡슐화는 정보 은닉을 실현하기 위한 주요 메커니즘으로 작용합니다.</p>
                    </div>
                    
                    <div class="article-section">
                        <h2>캡슐화의 시각적 표현</h2>
                        <p>캡슐화는 마치 약 캡슐처럼 객체의 내부 상태와 동작을 하나의 단위로 포장하는 개념입니다. 아래 다이어그램은 캡슐화된 객체를 시각적으로 표현합니다:</p>
                        
                        <div class="custom-diagram">
                            <div class="encapsulation-diagram">
                                <div class="capsule">
                                    <div class="capsule-label">객체 캡슐</div>
                                    <div class="private-section">
                                        <div class="section-label">Private 영역</div>
                                        <div class="section-content">
                                            <div class="attribute">- privateData: String</div>
                                            <div class="method">- calculateValue(): void</div>
                                        </div>
                                    </div>
                                    <div class="public-section">
                                        <div class="section-label">Public 영역</div>
                                        <div class="section-content">
                                            <div class="attribute">+ getData(): String</div>
                                            <div class="method">+ setData(value): void</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <p>위 다이어그램은 객체의 내부를 두 영역으로 구분합니다:</p>
                        <ul>
                            <li><strong>Private 영역:</strong> 외부에서 직접 접근할 수 없는 데이터와 메서드</li>
                            <li><strong>Public 영역:</strong> 외부에서 접근 가능한 인터페이스(메서드)</li>
                        </ul>
                        
                        <p>이러한 구조를 통해 객체는 내부 구현을 숨기고, 외부에서는 제공된 인터페이스를 통해서만 상호작용할 수 있습니다.</p>
                    </div>
                    
                    <div class="article-section">
                        <h2>캡슐화의 구현 방법</h2>
                        <p>객체지향 프로그래밍 언어에서는 주로 접근 제어자(Access Modifiers)를 사용하여 캡슐화를 구현합니다:</p>
                        
                        <div class="code-block">
                            <div class="code-header">
                                <div class="code-language">
                                    <i class="fab fa-java"></i>
                                    <span>Java 예제</span>
                                </div>
                                <button class="copy-btn" data-code="java-example">
                                    <i class="far fa-copy"></i>
                                    <span>복사</span>
                                </button>
                            </div>
                            <pre><code class="language-java">
public class BankAccount {
    // Private 필드 (외부에서 직접 접근 불가)
    private String accountNumber;
    private double balance;
    
    // Public 생성자
    public BankAccount(String accountNumber) {
        this.accountNumber = accountNumber;
        this.balance = 0.0;
    }
    
    // Public 메서드 (인터페이스)
    public double getBalance() {
        return balance;
    }
    
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
    
    public boolean withdraw(double amount) {
        if (amount > 0 && balance >= amount) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    // Private 메서드 (내부 구현)
    private void logTransaction(String type, double amount) {
        // 트랜잭션 로깅 로직
    }
}
                            </code></pre>
                        </div>
                        
                        <div class="mermaid-diagram">
                            <div class="mermaid">
                            classDiagram
                                class BankAccount {
                                    -accountNumber: String
                                    -balance: double
                                    -logTransaction(type: String, amount: double): void
                                    +BankAccount(accountNumber: String)
                                    +getBalance(): double
                                    +deposit(amount: double): void
                                    +withdraw(amount: double): boolean
                                }
                            </div>
                            <p class="img-caption">BankAccount 클래스의 UML 다이어그램</p>
                        </div>
                        
                        <div class="tip-box">
                            <h4><i class="fas fa-lightbulb"></i> 캡슐화 구현 팁</h4>
                            <p>캡슐화를 효과적으로 구현하기 위해서는 다음 원칙을 따르세요:</p>
                            <ul>
                                <li>클래스의 필드를 private으로 선언하여 직접 접근을 차단</li>
                                <li>필드에 접근하기 위한 public getter/setter 메서드 제공</li>
                                <li>setter 메서드에서 데이터 유효성 검사 수행</li>
                                <li>내부 구현 로직을 private 메서드로 캡슐화</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="article-section">
                        <h2>캡슐화의 실제 작동 방식</h2>
                        <p>캡슐화가 어떻게 작동하는지 시각적으로 이해하기 위해 간단한 예제를 살펴보겠습니다. 다음은 BankAccount 객체와 외부 코드가 어떻게 상호작용하는지 보여줍니다:</p>
                        
                        <div class="interactive-demo">
                            <h3>캡슐화 시뮬레이션</h3>
                            <div class="encapsulation-demo">
                                <div class="bank-account">
                                    <h4>BankAccount 객체</h4>
                                    <div class="account-internals">
                                        <div class="private-area">
                                            <h5>Private 영역</h5>
                                            <div class="account-field">
                                                <span>accountNumber:</span>
                                                <span id="account-number-value">AC12345</span>
                                            </div>
                                            <div class="account-field">
                                                <span>balance:</span>
                                                <span id="balance-value">0.00</span>
                                            </div>
                                        </div>
                                        <div class="public-interface">
                                            <h5>Public 인터페이스</h5>
                                            <button id="get-balance">getBalance()</button>
                                            <div class="method-input">
                                                <button id="deposit">deposit()</button>
                                                <input type="number" id="deposit-amount" placeholder="금액">
                                            </div>
                                            <div class="method-input">
                                                <button id="withdraw">withdraw()</button>
                                                <input type="number" id="withdraw-amount" placeholder="금액">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="interaction-arrow">
                                    <i class="fas fa-exchange-alt"></i>
                                </div>
                                <div class="client-code">
                                    <h4>Client 코드</h4>
                                    <div class="console">
                                        <div class="console-header">
                                            <span>Console</span>
                                            <button id="clear-console">Clear</button>
                                        </div>
                                        <div class="console-content" id="console-output"></div>
                                    </div>
                                    <div class="code-action">
                                        <div class="code-note">
                                            <p><i class="fas fa-info-circle"></i> 위의 버튼을 클릭하여 메서드를 호출해보세요.</p>
                                            <p class="error-message" id="direct-access-message" style="display: none;">
                                                <i class="fas fa-exclamation-triangle"></i> 오류: private 필드에 직접 접근할 수 없습니다!
                                            </p>
                                        </div>
                                        <button id="direct-access">account.balance = 1000000 (직접 접근 시도)</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <p>이 시뮬레이션은 캡슐화의 핵심 원칙을 보여줍니다:</p>
                        <ol>
                            <li>객체의 내부 상태(balance, accountNumber)는 직접 접근할 수 없습니다.</li>
                            <li>외부 코드는 객체가 제공하는 메서드(getBalance, deposit, withdraw)를 통해서만 상호작용할 수 있습니다.</li>
                            <li>메서드는 입력 값의 유효성을 검사하여 객체의 무결성을 보호합니다(예: 마이너스 금액 입금 거부).</li>
                        </ol>
                    </div>
                    
                    <div class="article-section">
                        <h2>정보 은닉과 캡슐화의 이점</h2>
                        
                        <div class="comparison-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th>이점</th>
                                        <th>설명</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>데이터 보호</td>
                                        <td>객체의 내부 상태를 외부에서 직접 변경할 수 없으므로 객체의 무결성이 유지됩니다.</td>
                                    </tr>
                                    <tr>
                                        <td>구현 변경 용이성</td>
                                        <td>내부 구현을 변경해도 인터페이스가 같다면 외부 코드에 영향을 주지 않습니다.</td>
                                    </tr>
                                    <tr>
                                        <td>코드 복잡성 감소</td>
                                        <td>객체 내부 구현 세부사항을 숨겨 외부 코드에서는 간단한 인터페이스만 보입니다.</td>
                                    </tr>
                                    <tr>
                                        <td>재사용성 향상</td>
                                        <td>잘 캡슐화된 객체는 다른 코드에서 쉽게 재사용할 수 있습니다.</td>
                                    </tr>
                                    <tr>
                                        <td>유지보수성 향상</td>
                                        <td>코드 변경 시 영향 범위가 제한되어 유지보수가 용이해집니다.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="mermaid-diagram">
                            <div class="mermaid">
                            flowchart TB
                                subgraph "캡슐화가 없는 경우"
                                A[Client A] -->|직접 접근| D[(필드 1)]
                                B[Client B] -->|직접 접근| D
                                C[Client C] -->|직접 접근| D
                                A -->|직접 접근| E[(필드 2)]
                                B -->|직접 접근| E
                                C -->|직접 접근| E
                                end
                                
                                subgraph "캡슐화된 경우"
                                F[Client A] -->|메서드 호출| G[인터페이스]
                                H[Client B] -->|메서드 호출| G
                                I[Client C] -->|메서드 호출| G
                                G -->|내부 접근| J[(캡슐화된 데이터)]
                                end
                            </div>
                            <p class="img-caption">캡슐화가 있는 경우와 없는 경우의 객체 접근 패턴 비교</p>
                        </div>
                        
                        <p>위 다이어그램에서 볼 수 있듯이, 캡슐화는 객체 내부 데이터에 대한 접근을 제어하고 체계화함으로써 코드의 구조를 개선합니다. 캡슐화가 없으면 여러 클라이언트가 객체의 내부 필드에 직접 접근하여 데이터 일관성을 해칠 수 있습니다.</p>
                    </div>
                    
                    <div class="article-section">
                        <h2>실제 사례: 정보 은닉과 캡슐화</h2>
                        <p>실제 소프트웨어 개발에서 정보 은닉과 캡슐화가 어떻게 적용되는지 살펴보겠습니다.</p>
                        
                        <h3>예제 1: 사용자 계정 관리</h3>
                        <div class="code-block">
                            <div class="code-header">
                                <div class="code-language">
                                    <i class="fab fa-js-square"></i>
                                    <span>JavaScript 예제</span>
                                </div>
                                <button class="copy-btn" data-code="js-example">
                                    <i class="far fa-copy"></i>
                                    <span>복사</span>
                                </button>
                            </div>
                            <pre><code class="language-javascript">
class User {
    #id;           // Private 필드 (ES2020 이상)
    #name;
    #email;
    #passwordHash;
    
    constructor(id, name, email, password) {
        this.#id = id;
        this.#name = name;
        this.#email = email;
        this.#passwordHash = this.#hashPassword(password);
    }
    
    // Public 메서드 (인터페이스)
    getName() {
        return this.#name;
    }
    
    getEmail() {
        return this.#email;
    }
    
    updateEmail(newEmail) {
        if (this.#validateEmail(newEmail)) {
            this.#email = newEmail;
            return true;
        }
        return false;
    }
    
    checkPassword(password) {
        return this.#passwordHash === this.#hashPassword(password);
    }
    
    // Private 메서드 (내부 구현)
    #validateEmail(email) {
        // 이메일 형식 검증 로직
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    }
    
    #hashPassword(password) {
        // 실제로는 보안 해시 알고리즘을 사용해야 함
        return `hashed_${password}`;
    }
}

// 클라이언트 코드
const user = new User(1, "홍길동", "hong@example.com", "secure123");
console.log(user.getName()); // "홍길동"

// 직접 접근 시도 (오류 발생 또는 undefined 반환)
// console.log(user.#name); // SyntaxError: Private field '#name' must be declared in an enclosing class
                            </code></pre>
                        </div>
                        
                        <h3>예제 2: 도형 클래스</h3>
                        <div class="code-block">
                            <div class="code-header">
                                <div class="code-language">
                                    <i class="fab fa-python"></i>
                                    <span>Python 예제</span>
                                </div>
                                <button class="copy-btn" data-code="python-example">
                                    <i class="far fa-copy"></i>
                                    <span>복사</span>
                                </button>
                            </div>
                            <pre><code class="language-python">
class Circle:
    def __init__(self, radius):
        # Python에서는 관례적으로 '_'로 시작하는 변수를 private로 간주
        self._radius = radius  # Protected 속성
        self.__area = self.__calculate_area()  # Private 속성
    
    # Public 메서드 (인터페이스)
    def get_radius(self):
        return self._radius
    
    def set_radius(self, radius):
        if radius > 0:
            self._radius = radius
            self.__area = self.__calculate_area()
            return True
        return False
    
    def get_area(self):
        return self.__area
    
    # Private 메서드 (내부 구현)
    def __calculate_area(self):
        return 3.14159 * self._radius * self._radius

# 클라이언트 코드
circle = Circle(5)
print(circle.get_radius())  # 5
print(circle.get_area())    # 78.53975

# Python에서는 네이밍 컨벤션을 통한 캡슐화이므로, 기술적으로는 접근 가능
# 하지만 이는 권장되지 않는 방식
print(circle._radius)       # 5 (경고: 내부 구현에 접근)

# 이름 맹글링(name mangling)을 통한 private 속성 보호
try:
    print(circle.__area)    # AttributeError
except AttributeError:
    print("__area에 직접 접근할 수 없음")
                            </code></pre>
                        </div>
                    </div>
                    
                    <div class="article-section">
                        <h2>장단점 및 고려사항</h2>
                        
                        <div class="key-points">
                            <h4>캡슐화의 장점</h4>
                            <ul>
                                <li><strong>데이터 보호:</strong> 객체의 상태를 불변식(invariant)에 따라 일관되게 유지</li>
                                <li><strong>유연성:</strong> 인터페이스를 유지하면서 내부 구현 변경 가능</li>
                                <li><strong>유지보수성:</strong> 코드 변경의 영향 범위를 제한하여 버그 전파 방지</li>
                                <li><strong>모듈성:</strong> 독립적인 컴포넌트 개발 지원</li>
                            </ul>
                        </div>
                        
                        <div class="warning-box">
                            <h4><i class="fas fa-exclamation-triangle"></i> 캡슐화의 잠재적 단점</h4>
                            <ul>
                                <li><strong>과도한 캡슐화:</strong> 너무 많은 getter/setter는 코드 복잡성을 증가시킬 수 있음</li>
                                <li><strong>성능 오버헤드:</strong> 직접 접근보다 메서드 호출이 약간의 오버헤드를 발생시킬 수 있음 (일반적으로 무시할 수 있는 수준)</li>
                                <li><strong>학습 곡선:</strong> 잘 설계된 인터페이스를 만들기 위해 더 많은 사전 계획이 필요</li>
                            </ul>
                        </div>
                        
                        <h3>캡슐화 설계 시 고려사항</h3>
                        <ol>
                            <li><strong>인터페이스와 구현 분리:</strong> 사용자에게 필요한 기능만 노출</li>
                            <li><strong>최소 권한 원칙:</strong> 외부에서 필요한 최소한의 기능만 제공</li>
                            <li><strong>불변식 유지:</strong> 객체의 상태가 항상 유효하도록 제약 조건 강제</li>
                            <li><strong>일관된 추상화 수준:</strong> 공개 메서드가 일관된 추상화 수준을 유지하도록 설계</li>
                        </ol>
                    </div>
                    
                    <div class="article-section">
                        <h2>결론</h2>
                        <p>정보 은닉과 캡슐화는 객체지향 프로그래밍의 핵심 원칙으로, 코드의 모듈성, 유지보수성, 재사용성을 향상시키는 데 중요한 역할을 합니다. 캡슐화는 객체의 내부 상태와 구현 세부사항을 숨기고, 외부에서는 잘 정의된 인터페이스를 통해서만 객체와 상호작용할 수 있게 함으로써 정보 은닉을 실현합니다.</p>
                        
                        <p>효과적인 캡슐화를 통해 얻을 수 있는 주요 이점은 다음과 같습니다:</p>
                        <ul>
                            <li>객체의 내부 상태를 보호하여 데이터 무결성 유지</li>
                            <li>클라이언트 코드와 객체 구현 간의 결합도 감소</li>
                            <li>내부 구현 변경 시 외부 코드에 미치는 영향 최소화</li>
                            <li>코드 이해와 유지보수가 용이해짐</li>
                        </ul>
                        
                        <p>객체지향 설계에서 잘 캡슐화된 객체는 마치 블랙박스와 같습니다. 외부 시스템은 객체가 어떻게 동작하는지 정확히 알 필요 없이, 단지 객체가 제공하는 인터페이스를 통해 무엇을 할 수 있는지만 알면 됩니다. 이러한 접근 방식은 대규모 소프트웨어 시스템 개발에서 복잡성을 관리하는 데 필수적입니다.</p>
                    </div>
                    
                    <div class="tags">
                        <span class="tag">객체지향 프로그래밍</span>
                        <span class="tag">정보 은닉</span>
                        <span class="tag">캡슐화</span>
                        <span class="tag">접근 제어자</span>
                        <span class="tag">소프트웨어 설계</span>
                    </div>
                    
                    <div class="author-section">
                        <div class="author-avatar">
                            <img src="/api/placeholder/160/160" alt="저자 아바타">
                        </div>
                        <div class="author-info">
                            <h4>김민수</h4>
                            <p>소프트웨어 아키텍트 및 객체지향 설계 전문가로 10년 이상의 경력을 보유하고 있습니다. 대규모 엔터프라이즈 애플리케이션 설계 및 개발 경험을 바탕으로 객체지향 원칙과 디자인 패턴에 대한 강의와 집필 활동을 하고 있습니다.</p>
                            <div class="author-social">
                                <a href="#"><i class="fab fa-twitter"></i></a>
                                <a href="#"><i class="fab fa-github"></i></a>
                                <a href="#"><i class="fab fa-linkedin"></i></a>
                            </div>
                        </div>
                    </div>
                </div>
            </article>
            
            <div class="related-posts" data-aos="fade-up">
                <h3>관련 기사</h3>
               <div class="posts-grid">
                   <div class="post-card">
                       <div class="post-image">
                           <img src="/api/placeholder/400/200" alt="객체지향의 다른 원칙들">
                       </div>
                       <div class="post-content">
                           <h4>객체지향의 다른 원칙들: 상속, 다형성, 추상화</h4>
                           <p>객체지향 프로그래밍의 나머지 세 가지 핵심 원칙에 대해 알아보고 이들이 어떻게 서로 연관되는지 알아봅니다.</p>
                           <a href="#" class="read-more">더 읽기 →</a>
                       </div>
                   </div>
                   <div class="post-card">
                       <div class="post-image">
                           <img src="/api/placeholder/400/200" alt="솔리드 원칙">
                       </div>
                       <div class="post-content">
                           <h4>SOLID 원칙: 객체지향 설계의 기초</h4>
                           <p>객체지향 설계의 5가지 핵심 원칙인 SOLID에 대해 알아보고 실제 코드에 어떻게 적용할 수 있는지 살펴봅니다.</p>
                           <a href="#" class="read-more">더 읽기 →</a>
                       </div>
                   </div>
                   <div class="post-card">
                       <div class="post-image">
                           <img src="/api/placeholder/400/200" alt="디자인 패턴">
                       </div>
                       <div class="post-content">
                           <h4>캡슐화를 활용한 디자인 패턴</h4>
                           <p>정보 은닉과 캡슐화 원칙을 효과적으로 활용하는 주요 디자인 패턴들을 코드 예제와 함께 살펴봅니다.</p>
                           <a href="#" class="read-more">더 읽기 →</a>
                       </div>
                   </div>
               </div>
           </div>
       </div>
   </section>
   
   <footer>
       <div class="container">
           <div class="footer-content">
               <div class="footer-logo">
                   <i class="fas fa-code"></i>
                   <span>CodeInsight</span>
               </div>
               <p>프로그래밍 개념을 하나씩 명확하게 설명합니다.</p>
               <div class="footer-links">
                   <div class="footer-column">
                       <h4>콘텐츠</h4>
                       <ul>
                           <li><a href="#">기사</a></li>
                           <li><a href="#">튜토리얼</a></li>
                           <li><a href="#">리소스</a></li>
                           <li><a href="#">도전 과제</a></li>
                       </ul>
                   </div>
                   <div class="footer-column">
                       <h4>연결</h4>
                       <ul>
                           <li><a href="#">뉴스레터</a></li>
                           <li><a href="#">트위터</a></li>
                           <li><a href="#">깃허브</a></li>
                           <li><a href="#">디스코드</a></li>
                       </ul>
                   </div>
                   <div class="footer-column">
                       <h4>법률</h4>
                       <ul>
                           <li><a href="#">개인정보 정책</a></li>
                           <li><a href="#">서비스 약관</a></li>
                           <li><a href="#">쿠키 정책</a></li>
                       </ul>
                   </div>
               </div>
           </div>
           <div class="footer-bottom">
               <p>&copy; 2025 CodeInsight. 모든 권리 보유.</p>
           </div>
       </div>
   </footer>
   
   <!-- JavaScript Libraries -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.js"></script>
   
   <!-- Custom JavaScript -->
   <script src="script.js"></script>
   
   <!-- Initialize Mermaid diagrams -->
   <script>
       document.addEventListener('DOMContentLoaded', function() {
           mermaid.initialize({
               startOnLoad: true,
               theme: 'dark',
               themeVariables: {
                   primaryColor: '#6366f1',
                   primaryTextColor: '#f3f4f6',
                   primaryBorderColor: '#4b5563',
                   lineColor: '#9ca3af',
                   secondaryColor: '#10b981',
                   tertiaryColor: '#374151'
               }
           });
       });
   </script>
</body>
</html>